//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


interface Array<T> {
    sum: T extends number
        ? () => number
        : (selector: (element: T) => number) => number;

    groupBy<T, TKey, TElement = unknown>(this: Array<T>, keySelector: (_: T) => TKey, elementSelector?: (_: T) => TElement): (TElement extends unknown ? T[] : TElement[]) & {key: string};
    
    includesWithComparer(searchElement: T, comparer: 'ordinalCaseInvariant'): boolean;
}



Array.prototype.sum = function (selector) {

    if (this.length === 0) return 0;

    let isArrayOfObjects = typeof this[0] === 'object';

    if (isArrayOfObjects && selector == undefined) throw 'Missing a selector.'

    return isArrayOfObjects ? this.map(selector).reduce((a, b) => a + b, 0) : this.reduce((a, b) => a + b, 0);
}

Array.prototype.groupBy = function <T, TKey, TElement>(keySelector: (_: T) => TKey, elementSelector?: (_: T) => TElement) {
    let map = (this as T[]).reduce(
        (entryMap, curr) => {
            let key = keySelector(curr);
            let value = elementSelector ? elementSelector(curr) : curr;
            return entryMap.set(key, [...entryMap.get(key) || [], value]);
        },
        new Map()
    );
    
    return [...map.entries()].map(([key, array]: [TKey, any]) => Object.defineProperty(array, 'key', {value: key})) as any;
}

Array.prototype.includesWithComparer = function <T>(searchElement: T, comparer: 'ordinalCaseInvariant'): boolean {
    if (comparer == 'ordinalCaseInvariant') {
        return this.find(e => ordinalCaseInvariantCompare(e, searchElement)) != null;
    }
    
    throw 'Function not implemented for provided comparer: ' + (comparer as any)?.toString();
}

function ordinalCaseInvariantCompare(str1, str2) {
    const upperStr1 = str1.toUpperCase();
    const upperStr2 = str2.toUpperCase();

    return upperStr1.localeCompare(upperStr2, "en", { sensitivity: "base" });
}