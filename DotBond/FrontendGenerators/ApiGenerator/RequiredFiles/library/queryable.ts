//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template.
//
//     Manual changes to this file may cause unexpected behavior in your application.
//     Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

import {combineLatest, map, Observable, of, OperatorFunction, switchMap, tap} from 'rxjs';
import {accessUsingPath, EMBEDDED_OBSERVABLE_STRING_PLACEHOLDER, evaluateInnerObservables, PrimitiveKey, queryInstanceId, sortAscCmp, sortDescCmp} from './miscellaneous';

type InferTElement<T> = (T extends (infer TElement)[] ? TElement : T);

export interface IQueryable<T> {

    /**
     * Projects each element of a sequence into a new form.
     * @param selector A transform function to apply to each source element.
     */
    map: <TResult>(selector: (input: InferTElement<T>) => TResult) => IQueryable<TResult[]>;

    /**
     * Filters a sequence of values based on a predicate.
     * @param predicate A function to test each element for a condition.
     */
    filter: (predicate: (input: InferTElement<T>) => boolean) => IQueryable<T>;

    /**
     * Sorts the elements of a sequence in ascending order according to a key.
     * @param key Key of an element object.
     */
    orderBy: (key?: PrimitiveKey<InferTElement<T>>, ...indexes: number[]) => IQueryable<T>;

    /**
     * Sorts the elements of a sequence in descending order according to a key.
     * @param key Key of an element object.
     */
    orderByDescending: (key?: PrimitiveKey<InferTElement<T>>, ...indexes: number[]) => IQueryable<T>;

    /**
     * The slice() method returns portion of an array
     * selected from start to end (end not included)
     * where start and end represent the index of items in that array.
     * @param start Zero-based index at which to start extraction.
     * @param end Zero-based index before which to end extraction
     */
    slice: (start: number, end: number) => IQueryable<T>;
    // Note: only positive numbers or 0

    /**
     * Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.
     * @param inner The sequence to join to the first sequence.
     * @param key Join key from each element of the first sequence.
     * @param innerKey Join key from each element of the second sequence.
     * @param resultSelector A function to create a result element from two matching elements.
     */
    join: <TInner, TResult>(inner: () => IQueryable<TInner[]>, key: PrimitiveKey<InferTElement<T>>,
                            innerKey: PrimitiveKey<TInner>,
                            resultSelector: (input: InferTElement<T>, innerInput: TInner) => TResult) => IQueryable<TResult[]>;

    /**
     * Correlates the elements of two sequences based on key equality and groups the results.
     * The default equality comparer is used to compare keys.
     * @param key Join key from each element of the first sequence.
     * @param innerKey Join key from each element of the second sequence.
     * @param resultSelector A function to create a result element from an element from the first sequence and a collection of matching elements from the second sequence.
     */
    groupJoin: <TInner, TResult>(inner: IQueryable<TInner[]>,
                                 key: PrimitiveKey<InferTElement<T>>,
                                 innerKey: PrimitiveKey<TInner>,
                                 resultSelector: (input: InferTElement<T>, innerInput: TInner[]) => TResult) => IQueryable<TResult[]>;

    /**
     * Projects each element of a sequence to an IEnumerable<out T> and combines the resulting sequences into one sequence.
     * @param selector A projection function to apply to each element.
     */
    flatMap: <TResult>(selector: (input: InferTElement<T>) => TResult[]) => IQueryable<TResult>;

    /**
     * Returns the first element of a sequence that satisfies the predicate,
     * or if predicate is not provided, just the first element of a sequence.
     * @param predicate A function to test each element for a condition.
     */
    find: (predicate?: (input: InferTElement<T>) => boolean) => InferTElement<T>;
    toList: () => T;

    /**
     * Same as find, except it uses the correct return type.
     */
    findAsync: (predicate?: (input: InferTElement<T>) => boolean) => Observable<InferTElement<T>>;

    /**
     * Same as toList, except it uses the correct return type.
     */
    toListAsync: () => Observable<T>;
}


/**
 * Client-side query engine
 */
// @ts-ignore
export class Queryable<T extends any[]> implements IQueryable<T> {

    /**
     * A list of properties that are accessed from objects returned by the find() function.
     * Even though Typescript is showing these functions to return models, they actually return Observable of those models.
     * Instead of accessing the actual property a map() operator will be added to the source Observable.
     */
    public static accessedPropertiesAfterFind = new Set<string>();

    private _shouldUseClientSideProcessing: boolean = false;
    private _queryOperatorsToApply: OperatorFunction<any, any>[] = [];
    private _mainObservable: Observable<any>;

    // Query context to apply to possible subqueries
    private readonly _queryInstanceId: number;

    /**
     *
     * @param mainObservable If a function, operators are not applied internally, instead they are provided as parameters so the code instantiating the Observable can use them.
     */
    constructor(mainObservable: Observable<{result: any, shouldUseClientSideProcessing: boolean}>) {

        this._mainObservable = mainObservable.pipe(map(({result, shouldUseClientSideProcessing}) => {
            this._shouldUseClientSideProcessing = shouldUseClientSideProcessing;
            return result;
        }));

        this._queryInstanceId = queryInstanceId.id;
    }

    map<TResult>(selector: (input: InferTElement<T>) => TResult): IQueryable<TResult[]> {

        // Handle operations using "toString" override
        let originalToString = Observable.prototype.toString;
        let operatorObservables: Observable<any>[] = [];
        let overridenToString = function (this: any) {
            operatorObservables.push(this);
            return EMBEDDED_OBSERVABLE_STRING_PLACEHOLDER + operatorObservables.length;
        };

        this._queryOperatorsToApply.push(
            tap(_ => Observable.prototype.toString = overridenToString),
            map(row => row.map(selector)),                                  // Apply the map
            tap(_ => Observable.prototype.toString = originalToString),     // Restore original "toString"
            switchMap(data => combineLatest(data.map(e => evaluateInnerObservables(e, operatorObservables))))
        );

        return this as any;
    }

    filter(predicate: any): IQueryable<T> {
        this._queryOperatorsToApply.push(map(row => row.filter(predicate) as T));

        return this as any;
    }

    orderBy(key?: PrimitiveKey<InferTElement<T>>, ...indexes: number[]): IQueryable<T> {
        if (indexes.length)
            indexes.forEach(index => key = (key as string).replace('%d', index.toString()) as any);

        this._queryOperatorsToApply.push(key
            ? map(row => row.sort((a, b) => sortAscCmp(accessUsingPath(a, key as string), accessUsingPath(b, key as string))))
            : map(row => row.sort((a, b) => a - b)))

        return this as any;
    }

    orderByDescending(key?: PrimitiveKey<InferTElement<T>>, ...indexes: number[]): IQueryable<T> {
        if (indexes.length)
            indexes.forEach(index => key = (key as string).replace('%d', index.toString()) as any);

        this._queryOperatorsToApply.push(key
            ? map(row => row.sort((a, b) => sortDescCmp(accessUsingPath(a, key as string), accessUsingPath(b, key as string))))
            : map(row => row.sort((a, b) => b - a)));

        return this as any;
    }

    slice(start: number, end: number): IQueryable<T> {
        this._queryOperatorsToApply.push(map(row => (row as any).slice(start, end)));

        return this as any;
    }

    join<TInner, TResult>(inner: () => IQueryable<TInner[]>, key: PrimitiveKey<InferTElement<T>>, innerKey: PrimitiveKey<TInner>, resultSelector: (input: InferTElement<T>, innerInput: TInner) => TResult): IQueryable<TResult[]> {

        // This join applies resultSelector to every outer-inner pair
        this._queryOperatorsToApply.push(switchMap(outerData => {
            queryInstanceId.id = this._queryInstanceId;
            return (inner() as any as Queryable<TInner[]>)._mainObservable.pipe(
                map(innerData => {

                    let innerMap = {} as { [key: string]: TInner[] };
                    innerData.map(e => accessUsingPath(e, innerKey)).forEach((keyValue, innerDataIdx) => keyValue != null && (innerMap[keyValue] ??= []).push(innerData[innerDataIdx]));

                    return outerData.flatMap(row => {

                        let outerKeyValue = accessUsingPath(row, innerKey)
                        let innerRows = innerMap[outerKeyValue];
                        return innerRows.map(innerRow => resultSelector(row, innerRow));
                    });
                })
            );
        }));

        return this as any;
    }

    groupJoin<TInner, TResult>(inner: IQueryable<TInner[]>,
                               key: PrimitiveKey<InferTElement<T>>,
                               innerKey: PrimitiveKey<TInner>,
                               resultSelector: (input: InferTElement<T>, innerInput: TInner[]) => TResult): IQueryable<TResult[]> {

        // This join applies resultSelector to every outer element and the array of matching inner elements
        this._queryOperatorsToApply.push(switchMap(outerData =>
            (inner as any as Queryable<TInner[]>)._mainObservable.pipe(
                map(innerData => {

                    let innerMap = {} as { [key: string]: TInner[] };
                    innerData.map(e => accessUsingPath(e, innerKey)).forEach((keyValue, innerDataIdx) => keyValue != null && (innerMap[keyValue] ??= []).push(innerData[innerDataIdx]));

                    return outerData.map(row => {

                        let outerKeyValue = accessUsingPath(row, innerKey)
                        let innerRows = innerMap[outerKeyValue];
                        return resultSelector(row, innerRows);
                    });
                })
            )));

        return this as any;
    }

    flatMap<TResult>(selector: any): IQueryable<TResult> {
        this._queryOperatorsToApply.push(map(row => (row as any).flatMap(selector)));
        return this as any;
    }

    find(predicate?: (input: InferTElement<T>) => boolean): InferTElement<T> {
        return this.findPrivate(predicate, true);
    }

    toList(): T {
        return this._mainObservable.pipe(
            switchMap(data => !this._shouldUseClientSideProcessing
                ? of(data)
                : of(data).pipe(
                    tap(_ => queryInstanceId.id = this._queryInstanceId),
                    ...(this._queryOperatorsToApply as [OperatorFunction<any, any>]),
                    tap(_ => queryInstanceId.id = null)))
        ) as any;
    }

    findAsync(predicate?: any): Observable<T extends (infer U)[] ? U : T> {
        return this.findPrivate(predicate, false);
    }

    toListAsync(): Observable<T> {
        return this.toList() as any;
    }

    private findPrivate(predicate?: any, createAccessOverride = false): any {

        return this._mainObservable.pipe(
            switchMap(data => {

                let resultObservable = of(data);

                if (this._shouldUseClientSideProcessing) {
                    predicate ??= _ => true;
                    this._queryOperatorsToApply.push(map(row => Array.isArray(row) ? row.find(predicate) : [row].find(predicate)));

                    if (createAccessOverride) {
                        for (let property of Queryable.accessedPropertiesAfterFind)
                            if (!resultObservable[property])
                                Object.defineProperty(resultObservable, property, {
                                    get: function () {
                                        return resultObservable.pipe(map(row => row?.[property]));
                                    }
                                })
                    }
                }

                return !this._shouldUseClientSideProcessing
                    ? resultObservable
                    : resultObservable.pipe(
                        tap(_ => queryInstanceId.id = this._queryInstanceId),
                        ...(this._queryOperatorsToApply as [OperatorFunction<any, any>]),
                        tap(_ => queryInstanceId.id = null));
            })
        ) as any;

    }
}
