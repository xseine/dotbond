using System.Reactive;
using System.Reactive.Linq;
using System.Reactive.Threading.Tasks;
using System.Text.RegularExpressions;
using DotBond.Generators;
using DotBond.Misc;
using DotBond.SyntaxRewriter.Core;
using DotBond.Workspace;
using DotBond.Workspace.IQLogger;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static DotBond.IntegratedQueryRuntime.TsRegexRepository;

namespace DotBond.IntegratedQueryRuntime;

public static class EndpointGenInitializer
{
    public static readonly string TsDefinitionsFile = FrontendDirectoryController.DetermineAngularPath(ApiGenerator.QueryServicePath);
    public static string ControllersPath;
    private static FileSystemWatcher _fileSystemWatcher;
    public static string CsprojPath;
    public const string QueryImplementationsFile = "QueryImplementations.cs";
    public const string QueryControllerFile = "QueryController.cs";


    public static void InitializeTranslator(FileObservable fileObservable, string csprojPath)
    {
        CsprojPath = csprojPath;
        var backendRoot = Directory.GetParent(csprojPath)!.FullName;
        ControllersPath = Path.Combine(backendRoot, "Controllers");

        var watcher = InitializeTsWatcher();
        var shouldAutoStart = IqLogger.IsOutOfDate();
        var languageVersion = fileObservable.LanguageVersion;

        var autogeneratedText = Utilities.GetAutogeneratedText();
        
        Observable.FromEventPattern<FileSystemEventArgs>(watcher, nameof(watcher.Changed)) // Repeat on change
            .Throttle(TimeSpan.FromMilliseconds(100))
            .Select(_ => 1)
            .StartWith(shouldAutoStart ? 1 : 0).Where(e => e != 0) // StartWith, if modification date is newer
            .Select(_ => EndpointGenLib.GenerateNewEndpoints(TsDefinitionsFile, ref fileObservable.Compilation)) // Generate translated content for queries and controller on top
            .Select(tuple =>
            {
                try
                {
                    return AfterCompileFixup(ref fileObservable.Compilation, languageVersion, tuple.Item1, tuple.Item2);
                }
                catch (Exception)
                {
                    return default;
                }
            }) // After compile, do: spreading, return types and .length
            .Where(e => e != default)
            .AfterComplete((value, cancellationToken) => Task.WhenAll(
                File.WriteAllTextAsync(Path.Combine(ControllersPath, QueryImplementationsFile), autogeneratedText + value.Item1, cancellationToken), // Write query implementations to file
                MergeControllerUpdates(Path.Combine(ControllersPath, QueryControllerFile), value.Item2, cancellationToken), // Write controller source to file
                AddDependencyIntoCsProj(cancellationToken), // Create dependency betweeen the two in .csproj
                WriteTsDefinitionsLockFile(cancellationToken) // Write ts lock file
                // Task.Delay(10_000, cancellationToken)   // why?
            ))
            .Subscribe(_ =>
            {
                IqLogger.LogTime();
                Console.WriteLine($"Updated queries' implementations. ({DateTime.Now.TimeOfDay:g})");
            }, (e) =>
            {
                Console.WriteLine("");
            }, () =>
            {
                Console.WriteLine("");
            });


        // Save from disposing
        _fileSystemWatcher = watcher;
    }

    private static FileSystemWatcher InitializeTsWatcher()
    {
        var watcher = new FileSystemWatcher(Directory.GetParent(TsDefinitionsFile)!.FullName);
        watcher.Filter = Path.GetFileName(TsDefinitionsFile)!;
        watcher.NotifyFilter = NotifyFilters.LastWrite;
        watcher.EnableRaisingEvents = true;
        watcher.IncludeSubdirectories = true;
        return watcher;
    }


    private static (string, string) AfterCompileFixup(ref Compilation diagnosticCompilation, LanguageVersion languageVersion, string pureTextualTranslation, string queryControllerSource)
    {
        var oldTree = diagnosticCompilation.SyntaxTrees.FirstOrDefault(e => e.FilePath == Path.Combine(ControllersPath, QueryImplementationsFile));
        if (oldTree != null)
            diagnosticCompilation = diagnosticCompilation.RemoveSyntaxTrees(oldTree);

        var translationTree = CSharpSyntaxTree.ParseText(pureTextualTranslation, new CSharpParseOptions(languageVersion)).WithFilePath(Path.Combine(ControllersPath, QueryImplementationsFile));
        diagnosticCompilation = diagnosticCompilation.AddSyntaxTrees(translationTree);
        var semanticModel = diagnosticCompilation.GetSemanticModel(translationTree);

        // Fix .Length property
        FixLengthProperty(ref diagnosticCompilation, ref translationTree, ref semanticModel);

        FixNonBooleanOperandsOfLogicalExpressions(ref diagnosticCompilation, ref translationTree, ref semanticModel);
        
        var actionsWithAlreadyKnowTypes = new List<string>();

        List<MethodDeclarationSyntax> newestActionsWithKnownTypes;
        // Infer return type
        var suffixIndex = 1;
        var isFirstSkip = true;

        var trimNamespaceRx = new Regex(string.Join("|", Regex.Matches(pureTextualTranslation, @"(?<=^using )[\S]+(?=;$)", RegexOptions.Multiline).Select(e => e.Value + ".").ToList()));
        while ((newestActionsWithKnownTypes = GetNewestActionsWithKnownTypes(translationTree, actionsWithAlreadyKnowTypes)).Any())
        {
            if (!isFirstSkip || (isFirstSkip = false))
            {
                diagnosticCompilation = diagnosticCompilation.ReplaceSyntaxTree(oldTree, translationTree);
                semanticModel = diagnosticCompilation.GetSemanticModel(translationTree);
            }

            var newClassDefinitions = new List<string>();

            // Execute spread
            ExecuteSpread(ref diagnosticCompilation, ref translationTree, ref semanticModel, newestActionsWithKnownTypes);

            var newestActionsWithKnownTypesNames = newestActionsWithKnownTypes.Select(e => e.Identifier.Text).ToList();

            var translationRootNode = translationTree.GetRoot();
            var actions = translationRootNode.DescendantNodes().OfType<MethodDeclarationSyntax>()
                .Where(method => newestActionsWithKnownTypesNames.Contains(method.Identifier.Text));
            var errors = new List<string>();
            translationRootNode = translationRootNode.ReplaceNodes(actions, (action, _) =>
            {
                // Finds the return statement and infers its type
                var returnStatement = translationTree.GetRoot().DescendantNodes().OfType<MethodDeclarationSyntax>()
                    .First(method => method.Identifier.Text == action.Identifier.Text).DescendantNodes().OfType<ReturnStatementSyntax>().First();
                var type = semanticModel.GetTypeInfo(returnStatement.Expression).Type;

                if (type.IsValueType || type.Name == "String") return action.WithReturnType(SyntaxFactory.ParseTypeName(type.Name).WithTrailingTrivia(SyntaxFactory.Space));
                
                // Handle only anonymous types, or generics with anonymous type arguments
                if (!type.IsAnonymousType && type is INamedTypeSymbol {IsGenericType: true} generic && generic.TypeArguments.All(e => !e.IsAnonymousType))
                {
                    var isAsync = action.Modifiers.Any(e => e.IsKind(SyntaxKind.AsyncKeyword));
                    return action.WithReturnType(SyntaxFactory.ParseTypeName((isAsync ? "Task<" : null) + trimNamespaceRx.Replace(type.ToString(), "") + (isAsync ? ">" : null)).WithTrailingTrivia(SyntaxFactory.Space));
                }


                TypeSyntax returnTypeIdentifier;
                var typeString = trimNamespaceRx.Replace(type.ToString(), "");
                if (IsAnonymousType(typeString))
                {
                    (returnTypeIdentifier, var classDefinition, var anonymousTypes) = GetAnonymousDefinition(typeString, action.Identifier.Text + "Type");

                    // Cause of this is a syntax error. If it happens, don't include the endpoint
                    if (classDefinition == null)
                    {
                        // Use this to find exact syntax errors in the compilation
                        // var compilationErrors = semanticModel.GetDiagnostics().Where(e => e.Severity == DiagnosticSeverity.Error).ToList();
                        errors.Add("Syntax error when generating endpoint:\n" + action);
                        return null;
                    }

                    newClassDefinitions.Add(classDefinition);


                    var anonInitsToReplace = action.DescendantNodes().OfType<AnonymousObjectCreationExpressionSyntax>().Select(anonObject =>
                        {
                            var anonObjectMembers = anonObject.Initializers.Select(e => e.NameEquals?.Name.Identifier.Text).Where(e => e != null).ToList();

                            return (anonObject, anonymousTypes.FirstOrDefault(e => e.classMembers.SequenceEqual(anonObjectMembers)).ClassName);
                        })
                        .Where(tuple => tuple.ClassName != null)
                        .ToList();

                    action = action.ReplaceNodes(anonInitsToReplace.Select(e => e.anonObject), (originalInit, init) =>
                    {
                        var newIdentifier = anonInitsToReplace.First(e => e.anonObject == originalInit).ClassName;

                        var a = SyntaxFactory.ObjectCreationExpression(SyntaxFactory.IdentifierName(newIdentifier).WithLeadingTrivia(SyntaxFactory.Space).WithTrailingTrivia(SyntaxFactory.Space),
                            null,
                            SyntaxFactory.InitializerExpression(
                                SyntaxKind.ObjectInitializerExpression,
                                init.OpenBraceToken,
                                SyntaxFactory.SeparatedList(
                                    init.Initializers.Select(e => SyntaxFactory.AssignmentExpression(
                                        SyntaxKind.SimpleAssignmentExpression, e.NameEquals.Name, e.Expression.WithLeadingTrivia(SyntaxFactory.Space))
                                    ).Cast<ExpressionSyntax>(), init.Initializers.GetSeparators()
                                ),
                                init.CloseBraceToken
                            )
                        );

                        return a;
                    });
                }
                else
                {
                    returnTypeIdentifier = SyntaxFactory.ParseTypeName(typeString);
                }

                return action.WithReturnType(returnTypeIdentifier.WithTrailingTrivia(SyntaxFactory.Space));
            });


            var returnTypeDeclarations = newClassDefinitions.Select(e => SyntaxFactory.ParseSyntaxTree(e.Replace("                ", "")).GetRoot().DescendantNodes().First());
            translationRootNode = translationRootNode.InsertNodesAfter(translationRootNode.DescendantNodes().OfType<ClassDeclarationSyntax>().Last(), returnTypeDeclarations);

            var errorComments = errors.Select(e => Regex.Replace(e, @"^(\s*)", "$1//", RegexOptions.Multiline)).Select(SyntaxFactory.Comment);
            translationRootNode = translationRootNode.InsertTriviaAfter(translationRootNode.DescendantNodes().OfType<MethodDeclarationSyntax>().LastOrDefault()?.GetTrailingTrivia().Last()
                                                                        ?? translationRootNode.DescendantNodes().OfType<ConstructorDeclarationSyntax>().First().GetTrailingTrivia().Last(), errorComments);

            foreach (var actionToRemove in errors.Select(e => Regex.Match(e, @"(?<=public virtual (?:object|Task<object>) )\w+").Value))
            {
                queryControllerSource = Regex.Replace(queryControllerSource, @"\[\w+\]\s*public override (?:object|Task<object>) " + actionToRemove + ".*", "");
            }
            
            suffixIndex++;
            actionsWithAlreadyKnowTypes.AddRange(newestActionsWithKnownTypesNames);
            oldTree = translationTree;
            translationTree = translationRootNode.SyntaxTree;
        }

        if (oldTree != null && diagnosticCompilation.ContainsSyntaxTree(oldTree))
            diagnosticCompilation = diagnosticCompilation.ReplaceSyntaxTree(oldTree, translationTree);

        var treeString = translationTree.GetText().ToString();
        treeString = treeString.Replace("System.Collections.Generic.", "").Replace("System.Linq.", "");
        // suffixIndex = 1;
        // treeString = Regex.Replace(treeString, @"new\s*\{", _ => $"new AnonymousType{suffixIndex++} {{");

        var newQueryControllerSource = Regex.Replace(queryControllerSource, @$"public override (?:object|Task<object>) (?<name>\w+){MatchBrackets(BracketType.Parenthasis)}",
            m => Regex.Match(treeString, @$"public virtual .*? {m.Groups["name"]}{MatchBrackets(BracketType.Parenthasis)}").Value).Replace("virtual", "override").Replace(" async ", " ");
        
        // Update controller syntax tree in compilation (Updated tree not used by anything currently) 
        var oldControllerSource = diagnosticCompilation.SyntaxTrees.FirstOrDefault(e => e.FilePath == Path.Combine(ControllersPath, ControllersPath));
        if (oldControllerSource != null)
            diagnosticCompilation = diagnosticCompilation.RemoveSyntaxTrees(oldControllerSource);
        var controllerTree = CSharpSyntaxTree.ParseText(newQueryControllerSource, new CSharpParseOptions(languageVersion)).WithFilePath(Path.Combine(ControllersPath, ControllersPath));
        diagnosticCompilation = diagnosticCompilation.AddSyntaxTrees(controllerTree);
        
        return (treeString, newQueryControllerSource);
    }



    private static List<MethodDeclarationSyntax> GetNewestActionsWithKnownTypes(SyntaxTree translationTree, List<string> actionsWithAlreadyKnownTypes)
    {
        return translationTree.GetRoot().DescendantNodes().OfType<MethodDeclarationSyntax>()
            .Where(method =>
            {
                return !actionsWithAlreadyKnownTypes.Contains(method.Identifier.Text)
                       && method.DescendantNodes().OfType<InvocationExpressionSyntax>()
                           .Where(inv => inv.Expression is IdentifierNameSyntax)
                           .Select(inv => ((IdentifierNameSyntax)inv.Expression).Identifier.Text)
                           .Where(methodName => methodName != EndpointGenLib.SpreadFunctionName)
                           .All(actionsWithAlreadyKnownTypes.Contains);
            })
            .ToList();
    }

    private static void ExecuteSpread(ref Compilation diagnosticCompilation, ref SyntaxTree translationTree, ref SemanticModel semanticModel, List<MethodDeclarationSyntax> methodsToAnalyze)
    {
        var oldTree = translationTree;
        // var spreadNodes = translationTree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>()
        //     .Where(e => e.Expression is IdentifierNameSyntax { Identifier.Text: "Spread" }).ToList();

        var spreadNodes = methodsToAnalyze.SelectMany(method => method.DescendantNodes().OfType<InvocationExpressionSyntax>()
            .Where(e => e.Expression is IdentifierNameSyntax { Identifier.Text: "Spread" })).ToList();

        if (spreadNodes.Any())
        {
            var parentInitializers = spreadNodes.Select(e => e.Parent.Parent as AnonymousObjectCreationExpressionSyntax).Distinct();

            var semanticModelLambdaCopy = semanticModel;

            translationTree = translationTree.GetRoot().ReplaceNodes(parentInitializers, (parentInitializer, _) =>
            {
                var existingInitializers = parentInitializer.Initializers.Where(e => !spreadNodes.Contains(e.Expression)).ToList();
                var newMembers = new List<AnonymousObjectMemberDeclaratorSyntax>();


                var spreadNodesInParent = spreadNodes.Where(node => parentInitializer.Contains(node)).ToList();
                var membersOfSpreadNodes = spreadNodesInParent
                    .Select(e => e.ArgumentList.Arguments.First().Expression)
                    .Select(objectToSpread => ((INamedTypeSymbol)semanticModelLambdaCopy.GetTypeInfo(objectToSpread).Type).GetMembers()
                        .Where(e => e is IPropertySymbol or IFieldSymbol)
                        .Select(e => e.Name).ToList()).ToArray();

                // Indexes are used to check if following nodes override member (same name)
                for (var idx = 0; idx < membersOfSpreadNodes.Length; idx++)
                {
                    var newMemberNames = idx == membersOfSpreadNodes.Length - 1 ? membersOfSpreadNodes[idx] : membersOfSpreadNodes[idx].Except(membersOfSpreadNodes[1..].SelectMany(e => e));

                    var objectToSpread = spreadNodesInParent[idx].ArgumentList.Arguments.First().Expression;
                    var leadingTrivia = spreadNodesInParent[idx].GetLeadingTrivia();

                    newMembers.AddRange(newMemberNames
                        .Select(SyntaxFactory.IdentifierName)
                        .Select(name => SyntaxFactory.AnonymousObjectMemberDeclarator(
                            SyntaxFactory.NameEquals(name, AbstractRewriterWithSemantics.CreateToken(SyntaxKind.EqualsToken, " = ")),
                            SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression, objectToSpread, name)).WithLeadingTrivia(leadingTrivia)).ToList());
                }


                // Fix the trivia
                var lastTrivia = parentInitializer.Initializers[^1].GetTrailingTrivia();
                if (existingInitializers.Any()) existingInitializers[^1] = existingInitializers[^1].WithoutTrailingTrivia();

                try
                {
                    newMembers[^1] = newMembers[^1].WithTrailingTrivia(lastTrivia);
                }
                catch (Exception ex)
                {
                    var errors = semanticModelLambdaCopy.GetDiagnostics().Where(e => e.Severity == DiagnosticSeverity.Error).ToList();
                    if (errors.Any())
                        Console.WriteLine($"There are {errors.Count} errors in the implementations.");
                    else
                        throw ex;
                }

                var separators = Enumerable.Repeat(AbstractRewriterWithSemantics.CreateToken(SyntaxKind.CommaToken, ",\n"), newMembers.Count + existingInitializers.Count - 1);

                parentInitializer = parentInitializer.WithInitializers(
                    SyntaxFactory.SeparatedList(existingInitializers.Concat(newMembers), separators));
                return parentInitializer;
            }).SyntaxTree;

            diagnosticCompilation = diagnosticCompilation.ReplaceSyntaxTree(oldTree, translationTree);
            semanticModel = diagnosticCompilation.GetSemanticModel(translationTree);
        }
    }

    /// <summary>
    /// Replace .Length with .Count when it's not an existing property. 
    /// </summary>
    private static void FixLengthProperty(ref Compilation diagnosticCompilation, ref SyntaxTree translationTree, ref SemanticModel semanticModel)
    {
        var oldTree = translationTree;
        var lengthProperty = translationTree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>()
            .Where(e => e.Name.GetText().ToString().Trim() == "Length").ToList();

        if (lengthProperty.Any())
        {
            var semanticModelLambdaCopy = semanticModel;
            translationTree = translationTree.GetRoot().ReplaceNodes(lengthProperty, (accessExpression, _) =>
            {
                var containsLength = semanticModelLambdaCopy.GetTypeInfo(accessExpression.Expression).Type is INamedTypeSymbol namedTypeSymbol && namedTypeSymbol.MemberNames.Contains("Length");

                if (containsLength) return accessExpression;

                var trailingTrivia = accessExpression.GetTrailingTrivia();
                return accessExpression.WithName(SyntaxFactory.IdentifierName("Count").WithTrailingTrivia(trailingTrivia));
            }).SyntaxTree;

            diagnosticCompilation = diagnosticCompilation.ReplaceSyntaxTree(oldTree, translationTree);
            semanticModel = diagnosticCompilation.GetSemanticModel(translationTree);
        }
    }

    private static void FixNonBooleanOperandsOfLogicalExpressions(ref Compilation diagnosticCompilation, ref SyntaxTree translationTree, ref SemanticModel semanticModel)
    {
        var oldTree = translationTree;
        var notExpressionsAndBinaryOperands = translationTree.GetRoot().DescendantNodes().OfType<PrefixUnaryExpressionSyntax>().Where(e => e.IsKind(SyntaxKind.LogicalNotExpression))
            .Concat(translationTree.GetRoot().DescendantNodes().OfType<BinaryExpressionSyntax>()
                .Where(e => e is { RawKind: (int)SyntaxKind.LogicalAndExpression or (int)SyntaxKind.LogicalOrExpression}).SelectMany(e => new [] {e.Left, e.Right}))
            .Distinct()
            .ToList();

        if (notExpressionsAndBinaryOperands.Any())
        {
            var semanticModelLambdaCopy = semanticModel;
            translationTree = translationTree.GetRoot().ReplaceNodes(notExpressionsAndBinaryOperands, (_, notOrBinExp) =>
            {
                var isNotExpression = notOrBinExp is PrefixUnaryExpressionSyntax;
                var isNotExpressionOperand = isNotExpression ? ((PrefixUnaryExpressionSyntax)notOrBinExp).Operand : null;
                var booleanOperatorType = semanticModelLambdaCopy.GetTypeInfo(isNotExpression ? isNotExpressionOperand : notOrBinExp).Type.Name;

                if (booleanOperatorType == "bool") return notOrBinExp;

                if (EndpointGenUtilities.NumericTypes.Contains(booleanOperatorType))
                    return SyntaxFactory.BinaryExpression(
                            isNotExpression ? SyntaxKind.EqualsExpression : SyntaxKind.NotEqualsExpression,
                            isNotExpression ? isNotExpressionOperand : notOrBinExp.WithoutTrailingTrivia(),
                            CreateToken(SyntaxKind.ExclamationEqualsToken, isNotExpression ? " == " : " != "),
                            SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(0)))
                        .WithLeadingTrivia(notOrBinExp.GetLeadingTrivia())
                        .WithTrailingTrivia(notOrBinExp.GetTrailingTrivia());

                return notOrBinExp;
            }).SyntaxTree;

            diagnosticCompilation = diagnosticCompilation.ReplaceSyntaxTree(oldTree, translationTree);
            semanticModel = diagnosticCompilation.GetSemanticModel(translationTree);
        }
        
    }


    /// <summary>
    /// Returns identifier of the return type, and its definition if it has to be created
    /// </summary>
    private static (TypeSyntax identifier, string classDefinition, List<(string ClassName, List<string> classMembers)> TypeDefinition)
        GetAnonymousDefinition(string typeString, string topLevelClassName)
    {
        var numberOfAnonymousClasses = typeString.Split("anonymous type:").Length - 1;
        var suffixIndex = numberOfAnonymousClasses;
        var index = suffixIndex;

        var rx = new Regex(MatchBrackets(BracketType.AngleBrackets));
        var typeDefinitions = new List<(string className, List<string> classMembers)>();
        Match anonymousMatch = null;

        string topLevelClassDefinition = null;
        var nestedDefinitions = new List<string>();
        
        
        while (typeString.Contains("<anonymous type:") &&
               (anonymousMatch = rx.Match(typeString[typeString.LastIndexOf("<anonymous type:")..])).Success) // Match anonymousMatch in rx.Matches(typeString))
        {
            var isTopLevelDefinition = typeString.Split("<anonymous type:").Length == 2;
            
            var className = isTopLevelDefinition ? topLevelClassName : $"AnonymousSubType{--index}";
            var splitNameAndTypeRx = new Regex(@$"(?<type>\w+\s*{MatchBrackets(BracketType.AngleBrackets)}?)\s+(?<name>\w+)\s*(,|$)");
            var members = splitNameAndTypeRx.Matches(anonymousMatch.Value["<anonymous type: ".Length..^1]).Select(e => e.Groups["name"].Value).ToList();

            var classDefinition = @$"
public class {className}
{{
    public {anonymousMatch.Value["<anonymous type: ".Length..^1].Replace(",", ";\n\tpublic")};
{(isTopLevelDefinition ? string.Join("\n\t", nestedDefinitions) : null)}}}
";

            if (!isTopLevelDefinition)
            {
                classDefinition = Regex.Replace(classDefinition, "\n(?=.+)", "\n\t");
                nestedDefinitions.Add(classDefinition);
            }
            else
            {
                topLevelClassDefinition = classDefinition;
            }

            typeString = typeString.Replace(anonymousMatch.Value, className);
            typeDefinitions.Add((isTopLevelDefinition ? className : $"{topLevelClassName}.{className}", members));
        }

        return (SyntaxFactory.ParseTypeName(typeString), topLevelClassDefinition, typeDefinitions);
    }

    private static bool IsAnonymousType(string typeString)
    {
        return typeString.Contains("<anonymous type:");
    }


    /// <summary>
    /// Continues the stream only after the provided Task from the previous emission has completed successfully, or has been cancelled.
    /// </summary>
    public static IObservable<TFirst> AfterComplete<TFirst>(this IObservable<TFirst> first, Func<TFirst, CancellationToken, Task> taskToCancel)
    {
        Task previousTask = null;
        CancellationTokenSource previousTaskCancellationSource = null;
        return Observable.Create<TFirst>(observer =>
        {
            return first.Subscribe(value =>
            {
                Observable.Return(value).Delay(_ =>
                {
                    var taskToAwait = previousTask;
                    previousTaskCancellationSource?.Cancel();
                    previousTaskCancellationSource = new();
                    previousTask = taskToCancel.Invoke(value, previousTaskCancellationSource.Token);

                    return taskToAwait == null || taskToAwait.IsCompleted ? Observable.Empty<Unit>() : taskToAwait.ToObservable();
                }).Subscribe(observer.OnNext);
            }, observer.OnError, observer.OnCompleted);
        });
    }

    private static async Task MergeControllerUpdates(string filePath, string contentToWrite, CancellationToken cancellationToken)
    {
        if (!File.Exists(filePath))
        {
            await File.WriteAllTextAsync(filePath, contentToWrite, cancellationToken);
            return;
        }
        
        var existingContent = await File.ReadAllTextAsync(filePath, cancellationToken);
        var existingActions = QueryActionsRx.Matches(existingContent);
        var modifiedActionsNames = existingActions.Where(e => e.Groups["attributes"].Value.Trim().Replace(" ", "") != "[HttpGet]"
                                                              || !e.Groups["implementation"].Value.StartsWith(" => base.")).Select(e => e.Groups["actionName"].Value).ToList();

        var actionsInNewVersion = QueryActionsRx.Matches(contentToWrite);
        
        // Actions that are either new or haven't been modified by user
        var actionsToWrite = actionsInNewVersion.Where(e => !modifiedActionsNames.Contains(e.Groups["actionName"].Value));
        
        foreach (var action in actionsToWrite)
        {
            var actionToOverride = existingActions.FirstOrDefault(e => e.Groups["actionName"].Value == action.Groups["actionName"].Value)?.Value;
            if (actionToOverride != null)
                existingContent = existingContent.Replace(actionToOverride, action.Value);
            else
                existingContent = Regex.Replace(existingContent, @"}\s*$",  "\t" + action.Value + "\n\n\n}\n");
        }
        
        // Unmodified actions from previous version that are no longer required
        // Note: modified version stay, so the developer's work is not deleted
        var actionsToDelete = existingActions.Where(e => !modifiedActionsNames.Contains(e.Groups["actionName"].Value)
                                                         && actionsInNewVersion.All(ee => ee.Groups["actionName"].Value != e.Groups["actionName"].Value)).Select(e => e.Value);

        foreach (var actionToDelete in actionsToDelete) 
            existingContent = existingContent.Replace(actionToDelete, "");

        
        // Update constructor
        var constructorRx = new Regex(@$"public {QueryControllerFile[..^3]}{MatchBrackets(BracketType.Parenthasis)}[\s\S]*?{MatchBrackets(BracketType.CurlyBrackets)}");
        existingContent = constructorRx.Replace(existingContent, constructorRx.Match(contentToWrite).Value);
        
        // Trim empty lines
        existingContent = Regex.Replace(existingContent, @"^(\s*\n){3,}", "\r\n\r\n", RegexOptions.Multiline);
        
        // Update using statements
        var newUsingStatements = Regex.Match(contentToWrite, @"^.*(?=namespace \w)", RegexOptions.Singleline).Value.Split("\n").Select(e => e.Trim());
        existingContent = Regex.Replace(existingContent, @"^.*(?=namespace \w)", e => string.Join(Environment.NewLine, e.Value.Split("\n").Select(e => e.Trim()).Concat(newUsingStatements).Distinct()) + Environment.NewLine, RegexOptions.Singleline);
        
        await File.WriteAllTextAsync(filePath, existingContent, cancellationToken);
    }
    
    private static async Task AddDependencyIntoCsProj(CancellationToken cancellationToken)
    {
        var text = @$"    <ItemGroup>
	  <Compile Update=""Controllers\{QueryImplementationsFile}"">
        <DependentUpon>{QueryControllerFile}</DependentUpon >
      </Compile>
    </ItemGroup>

     <ItemGroup>
	  <None Update=""Controllers\{QueryImplementationsFile}.locked"">
        <DependentUpon>{QueryImplementationsFile}</DependentUpon>
      </None>
    </ItemGroup>";

        var existingContent = await Observable.FromAsync(() => File.ReadAllTextAsync(CsprojPath, cancellationToken)).Retry(10).FirstAsync();

        var dependencyAlreadyAdded = existingContent.Contains(QueryControllerFile);
        if (dependencyAlreadyAdded) return;

        await File.WriteAllTextAsync(CsprojPath, existingContent.Replace("</Project>", text + "\n\n</Project>"), cancellationToken);
    }

    /// <summary>
    /// Creates a lock file with current definitions of custom queries.
    /// These values will be used for comparison
    /// </summary>
    private static async Task WriteTsDefinitionsLockFile(CancellationToken cancellationToken)
    {
        var retryCnt = 0;
        var tsDefinitionsFileContent = await Observable.FromAsync(() => File.ReadAllTextAsync(TsDefinitionsFile, cancellationToken))
            .Delay(_ => Observable.Timer(TimeSpan.FromMilliseconds(retryCnt++ * 100))).Retry(10)
            .FirstAsync();

        tsDefinitionsFileContent = tsDefinitionsFileContent.Replace("// @customQuery", "");

        var lockedVersion = Regex.Replace(
                Regex.Replace(tsDefinitionsFileContent, @"@Injectable\(\{[\s\S]*?\}\)", ""),
                @"export class [\s\S]*?(?=\s*@customQuery|}\s*$)", """
                    
                    let asQueryable: any;
                    export class QueryServiceLock {
                    
                        private ctx: any;
                    

                    """)
            .Replace("@customQuery", "@lockedQuery");


        lockedVersion = Regex.Replace(lockedVersion, @"(?<=import.*?)asQueryable,? ?", "", RegexOptions.Multiline);

        lockedVersion += """
            function lockedQuery(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<(...args: any) => any>) {
            
                let method = descriptor.value!.toString();
                descriptor.value = function () {
                    return method;
                }
            }
            """;

        var parentDirectory = Directory.GetParent(TsDefinitionsFile).FullName;
        await File.WriteAllTextAsync(Path.Combine(parentDirectory, "query.service.lock.ts"), lockedVersion, cancellationToken);
    }

    private static SyntaxToken CreateToken(SyntaxKind tokenKind, string text) => AbstractRewriterWithSemantics.CreateToken(tokenKind, text);
}